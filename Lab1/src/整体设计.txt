basic:
采用生产者&消费者模式来实现整个任务获取、分发、执行的流程
	1、整体需要一个任务读取线程、若干个任务执行线程，主线程初始化各种线程、锁、信号量。
	2、由于只需要一个输入文件，那么可以把等待IO输入的功能放在主线程中，主线程可以确定输入的file对象。在老师动态获取任务的演示代码中，调用recvAJob()获得的仅仅是下一个应该被计算的任务号，即在输入文件数组中的一个索引号，需要在processAJob()方法中通过IO读入该索引号对应的整个输入文件，并在读入的过程中进行累加运算。
	分析：
	首先，不同于演示代码，basic阶段的任务只存在一个输入文件，所以每个线程获取数独任务的文件是同一个（如果需要线程直接从文件IO获取的话）。
	数独问题不同于简单的累加计算，无法在串行读入题目的同时进行计算，即对于每一道数独题目，在获取到题面后，还需要调用dance_link算法进行计算并最终打印结果。
	由于本次实验的任务要求是要解决一个足够大的输入文件中的所有数独题，那么当输入文件足够大时，内存能否允许我们直接把整个文件读入是一个大问题。所以我的想法是主线程中维护一个固定大小的任务池，通过信号量限制任务读取线程和解题线程对任务池的访问，当信任务池为空（或者任务数量小于一个阈值的时候）从	输入文件中接着上次的位置继续读入一定数量的任务以补充任务池。
	3、关于缓冲区的分析：
	目前我理解的，需要在主线程中开辟任务池，那么任务读取线程和解题线程会对这个任务池进行互斥地访问（前者添加、后者读取）。
	为了避免各个线程在等待添加/获取任务时由于自选锁产生的cpu浪费，计划采用信号量来约束任务池的任务数量。
	4、程序流程图
	main---创建任务池
		   创建任务池的锁
		   创建两个信号量
		   获取时间戳1
		   根据参数创建一个或多个任务获取线程---试图通过信号量1进入临界区
		   								   ---进入临界去---通过IO从文件读入一部分任务添加到任务池
		   								   ---任务池任务足够---睡眠在信号量1上
		   根据参数循环创建多个解题线程---试图通过信号量2进入临界区
		   							 ---进入临界去---从任务池获取到一个任务---调用dance_link算法进行求解---打印结果
		   							 ---任务池任务不足---睡眠在信号量2上	 
		   循环对所有解题线程执行pthread_join---等待所有解题线程返回
		   获取时间戳2
		   计算耗时
		   程序结束
